import numpy as np

import matplotlib.pyplot as plt
import copy
from sklearn.linear_model import LinearRegression

import random
random.seed(1109)

#############################  Data Generation ################################################

            

def var_mu_comp(X: "the entire dataset",
                sig_th:  "sigma_theta",
                sig_x:    "sigma_x"):
            """

            Evaluation of posterior variance and mean


            """            
            m=len(X)
            var_post = 1/(1/sig_th**2 + m/sig_x**2) # posterior variance
            mu_post  = sum(X)/(sig_x**2/sig_th**2 + m) # posterior expectation        
            
            return var_post, mu_post
        
def data_generation(sig_th:  "sigma_theta",
                    sig_x:    "sigma_x",
                    data_mult:  "how we increase data",
                    data_len:  "overall data points",
                    s: "number of samples without replacement"):
    """
    
    For a given s and how we increase the dataset size, we 1) sample the entire data 2) we evaluation of posterior variance and mean for each dataset size
    
    
    """  
    theta = sig_th*np.random.randn(1);
    print("theta=", theta[0])

    
    if data_mult>s:
        
        
        XX = theta + np.random.randn(s*(data_mult**(data_len)))*sig_x;# generated entire data

        m_list=np.zeros(data_len)
        var_post_list=np.zeros(data_len)
        mu_post_list=np.zeros(data_len)
        X_list=[]
        
        for j in range(0,data_len):
            m = int(s*np.power(data_mult,j+1))
            X=XX[:m]
            X_list.append(X)
            var_post,mu_post=var_mu_comp(X,sig_th,sig_x)
            m_list[j], var_post_list[j], mu_post_list[j]=m,var_post,mu_post 
    else:
        
        
        min_num=int(np.log(s)/np.log(data_mult))
        XX = theta + np.random.randn(s*(data_mult**(data_len+min_num)))*sig_x;# generated entire data
    
        m_list=np.zeros(data_len)
        var_post_list=np.zeros(data_len)
        mu_post_list=np.zeros(data_len)
        X_list=[]        
        
        for j in range(0,data_len):
            m = int(s*np.power(data_mult,j+1+min_num))
            X=XX[:m]
            X_list.append(X)
            var_post,mu_post=var_mu_comp(X,sig_th,sig_x)
            m_list[j], var_post_list[j], mu_post_list[j]=m,var_post,mu_post         
        
    return X_list, m_list, var_post_list, mu_post_list




def sampling_mu_sgd(X: "data", 
                    s: "number of samples we will draw from the dataset",
                    sig_th: "sigma_theta",
                    sig_x: "sigma_x"):
    
    m=len(X)
    y = np.random.choice(X, s, replace=False); 
        # Subsample the data without replacement
        
    return sum(y)/(sig_x**2/sig_th**2 + m)*m/s; 

def BMBase(h: "scale or finest stepsize",
           N: "the number of increments",
           M: "the number of number of Monte carlo realisation"):
    """
    Generating 1-dimensional scaled BM with M realizations and N increments
    
    Return:
    W: M many realisation of BM with N evaluation points, matrix of M by N.
    
    """

    dw = np.sqrt(h)*np.random.randn(M,N) 

    W = np.insert(np.cumsum(dw,axis=1),0,0,axis=1)

    return W

def BMcoarse(W: "BM at finest level",
             IntNum: "the number of increments skipped for sampling at the coarser level"):
    """
    The Brownian motion generated by using the finest level of BM from BMBase(h,N,M)
   
    For example, if the finest stepsize is 2**(-10), we want to sample BM at the stepsize 2**(-8),
    then the IntNum=2**(-8)/2**(-10)=2**2=4.
        
    Returns:
    
    The BM is derived from the finest level

    
    """
    
    return W[:,::IntNum] #The BM is derived from the finest level#

#############################  Essential functions ################################################

def f(x,args):
    """
    
    Evaluation of f in the form of Ornsteinâ€“Uhlenbeck process
    
    
    """
    
    
    [mu,sigma2]=args
    
    return -(x-mu)/2/sigma2


def euler_onestep(initial: "initial evaluations, a vector of length the same as steps",
                  stepsize: "scalar",
                  dW: "BM increments (vector-valued)",
                  f: "the drift function",
                  g_c: "the diffusion coefficent",
                  args_f: "parameters needed for evaluating f"):
    """
    
    To calculate euler-forward onestep (vector-valued or scalar)
    
    
    """

    return  initial +stepsize * f(initial,args_f)+g_c*dW

#############################  Weak Convergence ################################################
#####        The reference solution can be approximated via the known invariant measure    #####
#####                                                                                      #####
###############################################################################################
def ref_im_sol(mu_post: "posterior mean",
               var_post: "posterior variance",
               func: "the function we will evaluate for the im"):
        # prepare for numerical integration to get true answer
        
        
        x = np.arange(-2,2,0.0001) + mu_post 
        #create grid centered around posteriour expectation
    
        y = func(x) *np.exp(-0.5*(x - mu_post )**2/var_post)/np.sqrt(2*np.pi*var_post) 
        #evaluate the functional on this grid multiplied by the posterior density
    
        return np.trapz(y,x)     
    

def ref_im_sols(mu_post_list: "the list of posterior mean",
                var_post_list: "the list of posterior variance",
                func: "the function we will evaluate for the im"):
    
    """
    
    To get reference solutions of Expectation of function of invariant measure for different m 
    
    Note the invariant measure is normal with posterior mean and varaince
    
    """
    
    true_ans_list=np.zeros(len(var_post_list))
    
    for j in range(len(var_post_list)):
        
        var_post,mu_post=var_post_list[j], mu_post_list[j] 
        
        true_ans_list[j]=ref_im_sol(mu_post, var_post, func)
    
    return true_ans_list

def functional_euler_generator(n_experiments: "the number of number of Monte carlo realisation",
                               T:"terminal time",
                               h: "stepsize we will evaluate Euler", 
                               f: "the drift function",
                               g: "the diffusion coefficent",
                               initial: "initial condition",
                               mu_post: "posterior mean", 
                               var_post: "posterior variance",  
                               func: "the functional we will evaluate under expection wrt IM"):
     

                
            args_f=[mu_post,var_post]
        

            n1=int(T/h)
            
            #setting initial conditions which are constants for simplicity
            euler_sol = np.zeros(n_experiments)+initial
                     
 
            for i1 in range(1,n1+1):
                
                dBM=np.sqrt(h)*np.random.randn(n_experiments) 
                euler_sol = euler_onestep(euler_sol,
                                          h,
                                          dBM,
                                          f,
                                          g,
                                          args_f)
    

            return np.mean(func(euler_sol)),np.var(func(euler_sol))
    
def functional_sgd_generator(n_experiments: "the number of number of Monte carlo realisation",
                               T: "terminal time",
                               h: "stepsize we will evaluate Euler", 
                               f: "the drift function",
                               g: "the diffusion coefficent",
                               initial: "initial condition",
                               s: "number of samples without replacement",
                               sig_th: "sigma_theta",
                               sig_x:  "sigma_x",
                               X: "data of size m", 
                               mu_post: "list of posterior mean", 
                               var_post: "list of posterior variance",  
                               func: "the functional we will evaluate under expection wrt IM"):

 

            n1=int(T/h)
            
            #setting initial conditions which are constants for simplicity
            sgd_sol = np.zeros(n_experiments)+initial
                     
 
            for i1 in range(1,n1+1):
                
                dBM=np.sqrt(h)*np.random.randn(n_experiments) 

                    
                mu_sgd=sampling_mu_sgd(X,s, 
                                      sig_th,sig_x)
                    
                args_f_temp=[mu_sgd,var_post]   
            
                sgd_sol = euler_onestep(sgd_sol,
                                        h,
                                        dBM,
                                        f,
                                        g,
                                        args_f_temp)

            return np.mean(func(sgd_sol)),np.var(func(sgd_sol))    

def functional_sols_generator(n_experiments: "the number of number of Monte carlo realisation",
                               epsilon: "error level",
                               h_list: "list of stepsizes we will evaluate Euler", 
                               f: "the drift function",
                               g: "the diffusion coefficent",
                               initial: "initial condition",
                               s: "number of samples without replacement",
                               sig_th: "sigma_theta",
                               sig_x:  "sigma_x",
                               X_list: "list of datas with respect different m", 
                               m_list: "list of m", 
                               mu_post_list: "list of posterior mean", 
                               var_post_list: "list of posterior variance",  
                               func: "the functional we will evaluate under expection wrt IM"):
    """
    
    
    
    """       

    num_m=len(m_list)    

    euler_sols=[[] for i in range(num_m)]
    sgd_sols=[[] for i in range(num_m)]
        
    euler_vars=[[] for i in range(num_m)]
    sgd_vars=[[] for i in range(num_m)]    
    
    
    
    for j in range(num_m):
                
        
        T=3*np.log(1/epsilon)/m_list[j]
        for k in range(len(h_list)):
            
            h_current=h_list[k]/m_list[j]
            
            x1,v1=functional_euler_generator(n_experiments,T,
                                             h_current, 
                                             f,
                                             g,
                                             initial,
                                             mu_post_list[j], 
                                             var_post_list[j],  
                                             func)
            if s==0:
                s=int(m_list[j]-1)
                
            x2,v2=functional_sgd_generator(n_experiments,T,
                                                       h_current, 
                                                       f,
                                                       g,
                                                       initial,
                                                       s,
                                                       sig_th,
                                                       sig_x,
                                                       X_list[j],                                                                                                mu_post_list[j], 
                                                       var_post_list[j],  
                                                       func)
                     

            euler_sols[j].append(x1)
            sgd_sols[j].append(x2)
            euler_vars[j].append(v1)
            sgd_vars[j].append(v2)        

    return euler_sols, sgd_sols, euler_vars, sgd_vars


def final_error(gt_list: "ground truth list for different m",
                euler_sols_list: "euler functional sol list for different m and h",
                sgd_sols_list: "sgd functional sol list for different m and h"):
    
    num_m=len(gt_list)
    rmse_run = len(euler_sols_list)

    num_h=len(euler_sols_list[0])
    # how many experiments we do to calculate rmse   
    
    full_err_euler=np.zeros((num_m,num_h))
    # store the rmse for the full Euler
    full_err_sgd=np.zeros((num_m,num_h))
    # store the rmse for the SGLD    
    
    for i in range(num_m):
        for j in range(num_h):
            current_euler_error=[(euler_sols_list[i][j]-gt_list[i])**2 for k in range(rmse_run)]
            current_sgd_error=[(sgd_sols_list[i][j]-gt_list[i])**2 for k in range(rmse_run)]
            
            full_err_euler[i,j]=np.mean(current_euler_error)
            full_err_sgd[i,j]=np.mean(current_sgd_error)
            
    return  full_err_euler, full_err_sgd       
            

        
########################### Strong Convergence ###########################

def ref_pathwise_sols_generator(W: "BM paths", 
                                  h_ref: "finest stepsize" , 
                                  f: "the drift function",
                                  g: "the diffusion coefficent",
                                  args_f: "parameters needed for evaluating f",
                                  initial: "initial condition"):
    
        
    ###to get the reference solution:
    
    n_experiments,n_ref=W.shape
    
    sol_ref = np.zeros(n_experiments)+initial

    dW=W[:,1:]-W[:,:-1]
    
    for i in range(1,n_ref):               
        sol_ref = euler_onestep(sol_ref,
                                h_ref,
                                dW[:,i-1],
                                f,
                                g,
                                args_f)
    
    return sol_ref


def euler_path_sols_generator(W: "BM paths", 
                                h_list: "list of stepsizes we will evaluate Euler",  
                                h_ref: "finest stepsize" , 
                                f: "the drift function",
                                g: "the diffusion coefficent",
                                args_f: "parameters needed for evaluating f",
                                initial: "initial condition"):
    """
    
    Getting Euler solutions of the final point at different stepsizes 
    
    (For SGD scheme, only need to change args_f)
    
    """       
    
    n_experiments,n_ref=W.shape

    euler_sols=[]
    
    for k in range(len(h_list)):
        
        
        current_factor=int(h_list[k]/h_ref) 

        n1=int(n_ref/ current_factor)


        #setting initial conditions which are constants for simplicity
        euler_sol = np.zeros(n_experiments)+initial
           
        BM=BMcoarse(W,current_factor)
        dBM=BM[:,1:]-BM[:,:-1]            

        for i1 in range(1,n1+1):
                
            euler_sol = euler_onestep(euler_sol,
                                      h_list[k],
                                      dBM[:,i1-1],
                                      f,
                                      g,
                                      args_f)

            
        euler_sols.append(euler_sol)



    return euler_sols



def mean_error(sol: "true solution with M many samples",
               ref_sol: "simulation with M many samples"):
    """
    
    for strong convergence error
    
    """
    return (np.mean(np.abs(sol-ref_sol)**2))**(1/2)


def generate_error_list(sol_ref: "true solution with M many samples",
                       sol_list:  "simulations of different stepsize with M many samples"):
    
    assert len(sol_ref)==len(sol_list[0])
    
    error_list =[]
    for i in range(len(sol_list)):
        
        error_list.append(mean_error(sol_ref,sol_list[i]))
        
        
    return error_list

def slope_plot(i_list: "power list of base", 
                    plot_list: "error list",
                    tick_list: "tick points shown in plot",
                    fontsize=14,
                    label="Euler method with slope",
                    ylabel="Error",
                    xlabel="Stepsize",
                    base=2,
                    savefig=False):
    

    figsize=(6,4)

    linestyle_markers=['g-+','r-.x','b:^','k--o']


    legends=[]
    
    model = LinearRegression()    
    x_prep=np.array(i_list).reshape(-1, 1)
    if base==2:
        y_prep=np.log2(plot_list)
    else:
        y_prep=np.log2(plot_list)/np.log2(base)
        
    model.fit(x_prep, y_prep)
        
    print('Regression coefficient is ', -model.coef_[0])
    plt.plot(i_list, plot_list, linestyle_markers[1],
             label=label+" %.2f"%(-model.coef_[0]))
        

    
    plt.legend(fontsize=fontsize-1)
    
    plt.yscale('log')
    plt.ylabel(ylabel,fontsize=fontsize)
    plt.xlabel(xlabel,fontsize=fontsize) 
    plt.grid()
        
    plt.xticks(tick_list)
 
            
    if savefig:
        plt.savefig(savefig,dpi=300)
        plt.show()
    else:    
        plt.show()

        
def sgd_path_sols_generator(X: "entire dataset",
                            s: "number of samples to be drawn from dataset",
                            sig_th: "sigma theta",
                            sig_x: "sigma_x",
                            W: "BM paths", 
                            h_list: "list of stepsizes we will evaluate Euler",  
                            h_ref: "finest stepsize" , 
                            f: "the drift function",
                            g: "the diffusion coefficent",
                            args_f: "parameters needed for evaluating f",
                            initial: "initial condition"):
    """
    
    Getting Euler solutions of the final point at different stepsizes 
    
    (For SGD scheme, only need to change args_f)
    
    """       
    
    n_experiments,n_ref=W.shape

    sgd_sols=[]
    
    for k in range(len(h_list)):
        
        
        current_factor=int(h_list[k]/h_ref) 

        n1=int(n_ref/ current_factor)


        #setting initial conditions which are constants for simplicity
        sgd_sol = np.zeros(n_experiments)+initial
           
        BM=BMcoarse(W,current_factor)
        dBM=BM[:,1:]-BM[:,:-1]            

        for i1 in range(1,n1+1):
            
            mu_sgd=sampling_mu_sgd(X,
                                   s, 
                                   sig_th,
                                   sig_x)      
                
            args_f_sampled=[mu_sgd,args_f[-1]]  
            
            sgd_sol = euler_onestep(sgd_sol,
                                      h_list[k],
                                      dBM[:,i1-1],
                                      f,
                                      g,
                                      args_f_sampled)

            
        sgd_sols.append(sgd_sol)



    return sgd_sols      

def generate_error_list2(euler_list: "euler simulations of different stepsize with M many sample",
                         sgd_list:  "sdg simulations of different stepsize with M many samples"):
    
    assert len(euler_list)==len(sgd_list)
    assert len(euler_list[0])==len(sgd_list[0])
    
    error_list =[]
    for i in range(len(sgd_list)):
        
        error_list.append(mean_error(euler_list[i],sgd_list[i]))
        
        
    return error_list
# ########################### Variance ###########################

# def full_func_var_generator(n_experiments: "the number of number of Monte carlo realisation",
#                                n_ref: "the number of increments",
#                                h_list: "list of stepsizes we will evaluate Euler", 
#                                f: "the drift function",
#                                g: "the diffusion coefficent",
#                                initial: "initial condition",
#                                s: "number of samples without replacement",
#                                sig_th: "sigma_theta",
#                                sig_x:  "sigma_x",
#                                X_list: "list of datas with respect different m", 
#                                m_list: "list of m", 
#                                mu_post_list: "list of posterior mean", 
#                                var_post_list: "list of posterior variance",  
#                                func: "the functional we will evaluate under expection wrt IM",
#                                t0=0):
#     """
    
    
    
#     """       

#     num_m=len(m_list)    

#     euler_vars=[[] for i in range(num_m)]
#     sgd_vars=[[] for i in range(num_m)]
        
    
    
#     for j in range(num_m):
                
#         args_f=[mu_post_list[j],var_post_list[j]]
        
        
#         for k in range(len(h_list)):
            
#             h_current=h_list[k]/m_list[j]
        
#             current_factor=int(h_list[k]/h_list[-1]) 

#             n1=int(n_ref/ current_factor)
#             #setting initial conditions which are constants for simplicity
#             euler_sol = np.zeros(n_experiments)+initial
#             sgd_sol = np.zeros(n_experiments)+initial
            

            
#             dBM=np.sqrt(h_current)*np.random.randn(n_experiments,n_ref)          
 
#             for i1 in range(1,n1+1):
                
#                 euler_sol = euler_onestep(euler_sol,
#                                           h_current,
#                                           dBM[:,i1-1],
#                                           f,
#                                           g,
#                                           args_f)

#                 mu_sgd=sampling_mu_sgd(X_list[j],
#                                        s, 
#                                        sig_th,
#                                        sig_x)      
                
#                 args_f_temp=[mu_sgd,var_post_list[j]]   
            
#                 sgd_sol = euler_onestep(sgd_sol,
#                                         h_current,
#                                         dBM[:,i1-1],
#                                         f,
#                                         g,
#                                         args_f_temp)

#             euler_vars[j].append(np.var(func(euler_sol)))
#             sgd_vars[j].append(np.var(func(sgd_sol)))
        

#     return euler_vars, sgd_vars

